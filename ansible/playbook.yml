---
# =========================================================
# 1) BASE HARDENING / USERS / NETWORK / UFW  (ALL HOSTS)
# =========================================================
- name: Configure all servers
  hosts: all
  become: yes

  tasks:
    - name: Set timezone
      timezone:
        name: Europe/Tallinn

    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    # ⚠️ Самый долгий шаг. Если хочешь ускорить — закомментируй.
    - name: Upgrade all packages
      apt:
        upgrade: dist
        autoremove: yes
        autoclean: yes
      tags: [slow]

    - name: Install common packages
      apt:
        name:
          - vim
          - curl
          - wget
          - git
          - htop
          - net-tools
          - ufw
          - ca-certificates
          - gnupg
          - lsb-release
          - rsync
        state: present

    - name: Create devops user
      user:
        name: devops
        shell: /bin/bash
        groups: sudo
        append: yes
        create_home: yes
        password: "{{ 'devops123' | password_hash('sha512') }}"

    - name: Create .ssh directory for devops
      file:
        path: /home/devops/.ssh
        state: directory
        owner: devops
        group: devops
        mode: "0700"

    # Берём публичный ключ, которым vagrant уже умеет логиниться, прямо с VM
    - name: Read vagrant authorized_keys
      slurp:
        src: /home/vagrant/.ssh/authorized_keys
      register: vagrant_authkeys
      ignore_errors: yes

    - name: Add vagrant key(s) to devops authorized_keys
      authorized_key:
        user: devops
        key: "{{ vagrant_authkeys.content | b64decode }}"
        state: present
      when: vagrant_authkeys is defined and vagrant_authkeys.content is defined

    - name: Configure SSH - disable password authentication
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication no'
        state: present
      notify: restart ssh

    - name: Configure SSH - disable root login
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitRootLogin'
        line: 'PermitRootLogin no'
        state: present
      notify: restart ssh

    - name: Configure SSH - enable pubkey authentication
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PubkeyAuthentication'
        line: 'PubkeyAuthentication yes'
        state: present
      notify: restart ssh

    - name: Disable other users login (except devops and vagrant)
      user:
        name: "{{ item }}"
        shell: /usr/sbin/nologin
      loop:
        - ubuntu
        - nobody
      ignore_errors: yes

    - name: Set umask to 022 in /etc/profile
      lineinfile:
        path: /etc/profile
        regexp: '^umask'
        line: 'umask 022'
        state: present

    - name: Set umask in /etc/bash.bashrc
      lineinfile:
        path: /etc/bash.bashrc
        regexp: '^umask'
        line: 'umask 022'
        state: present

    - name: Set umask in /etc/login.defs
      lineinfile:
        path: /etc/login.defs
        regexp: '^UMASK'
        line: 'UMASK           022'
        state: present

    - name: Configure sudo for devops user
      lineinfile:
        path: /etc/sudoers.d/devops
        line: 'devops ALL=(ALL:ALL) ALL'
        state: present
        create: yes
        mode: "0440"
        validate: 'visudo -cf %s'

    - name: Ensure sudo requires password
      lineinfile:
        path: /etc/sudoers.d/devops
        regexp: '^devops.*NOPASSWD'
        state: absent
        validate: 'visudo -cf %s'

    - name: Configure UFW default policies
      ufw:
        direction: "{{ item.direction }}"
        policy: "{{ item.policy }}"
      loop:
        - { direction: "incoming", policy: "deny" }
        - { direction: "outgoing", policy: "allow" }

    - name: Allow SSH
      ufw:
        rule: allow
        port: "22"
        proto: tcp

    - name: Enable UFW
      ufw:
        state: enabled

    - name: Set static IP configuration
      copy:
        dest: /etc/netplan/99-static-ip.yaml
        content: |
          network:
            version: 2
            ethernets:
              eth1:
                addresses:
                  - {{ vm_ip }}/24
        owner: root
        group: root
        mode: "0644"
      notify: apply netplan

    - name: Update /etc/hosts with all VMs
      blockinfile:
        path: /etc/hosts
        block: |
          192.168.56.10 loadbalancer lb
          192.168.56.11 webserver1 web1
          192.168.56.12 webserver2 web2
          192.168.56.13 appserver app
          192.168.56.14 jenkinsserver jenkins
        marker: "# {mark} ANSIBLE MANAGED BLOCK"

  handlers:
    - name: restart ssh
      service:
        name: ssh
        state: restarted

    - name: apply netplan
      command: netplan apply
      ignore_errors: yes


# =========================================================
# 2) DOCKER (WEB + APP + JENKINS)
# =========================================================
- name: Install Docker (web/app/jenkins) and configure permissions
  hosts: appserver,webservers,jenkinsservers
  become: yes

  tasks:
    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present

    - name: Install Docker Engine and Compose plugin
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-compose-plugin
        state: present
        update_cache: yes

    - name: Start and enable Docker
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Add devops user to docker group
      user:
        name: devops
        groups: docker
        append: yes

    - name: Add jenkins user to docker group (only on Jenkins VM)
      user:
        name: jenkins
        groups: docker
        append: yes
      when: "'jenkinsservers' in group_names"


# =========================================================
# 3) LOAD BALANCER (NGINX)
# =========================================================
- name: Configure Load Balancer
  hosts: loadbalancer
  become: yes

  tasks:
    - name: Install Nginx
      apt:
        name: nginx
        state: present

    - name: Remove default Nginx config
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent

    - name: Create Nginx load balancer config
      copy:
        dest: /etc/nginx/sites-available/loadbalancer
        content: |
          upstream webservers {
              server 192.168.56.11:80;
              server 192.168.56.12:80;
          }

          server {
              listen 80;
              server_name loadbalancer;

              location / {
                  proxy_pass http://webservers;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              }
          }

    - name: Enable load balancer config
      file:
        src: /etc/nginx/sites-available/loadbalancer
        dest: /etc/nginx/sites-enabled/loadbalancer
        state: link

    - name: Allow HTTP on Load Balancer (public entry point)
      ufw:
        rule: allow
        port: "80"
        proto: tcp

    - name: Restart Nginx
      systemd:
        name: nginx
        state: restarted
        enabled: yes


# =========================================================
# 4) WEB SERVERS (NGINX + UFW restricted)
#    - HTTP ONLY from LB (192.168.56.10)
#    - NO 3000 rules on webservers
# =========================================================
- name: Configure Web Servers
  hosts: webservers
  become: yes

  tasks:
    - name: Install Nginx
      apt:
        name: nginx
        state: present

    - name: Disable IPv6 in UFW (webservers)
      ansible.builtin.lineinfile:
        path: /etc/default/ufw
        regexp: '^IPV6='
        line: 'IPV6=no'
      notify: reload ufw (webservers)


    - name: Read UFW rules (numbered) on webservers
      ansible.builtin.command: ufw status numbered
      register: ufw_web_numbered
      changed_when: false

    - name: Remove public HTTP (80/tcp Anywhere) on webservers
      ansible.builtin.shell: |
        set -e
        echo "{{ ufw_web_numbered.stdout }}" \
          | sed -n -E 's/^\[\s*([0-9]+)\]\s+80\/tcp\s+ALLOW IN\s+Anywhere\s*$/\1/p' \
          | sort -rn \
          | while read -r n; do yes | ufw delete "$n"; done
      args:
        executable: /bin/bash
      register: ufw_rm_web_80_any
      changed_when: ufw_rm_web_80_any.stdout != ""
      failed_when: false

    - name: Remove public HTTP IPv6 (80/tcp v6 Anywhere) on webservers
      ansible.builtin.shell: |
        set -e
        echo "{{ ufw_web_numbered.stdout }}" \
          | sed -n -E 's/^\[\s*([0-9]+)\]\s+80\/tcp\s+\(v6\)\s+ALLOW IN\s+Anywhere\s+\(v6\)\s*$/\1/p' \
          | sort -rn \
          | while read -r n; do yes | ufw delete "$n"; done
      args:
        executable: /bin/bash
      register: ufw_rm_web_80_v6_any
      changed_when: ufw_rm_web_80_v6_any.stdout != ""
      failed_when: false

    - name: Remove any 3000/tcp allow rules on webservers (safe)
      ansible.builtin.shell: |
        set +e
        ufw status numbered | sed -n -E 's/^\[\s*([0-9]+)\]\s+3000\/tcp\s+ALLOW IN\s+.*$/\1/p' | sort -rn | while read -r n; do
          yes | ufw delete "$n"
        done
        exit 0
      args:
        executable: /bin/bash
      register: ufw_rm_web_3000
      changed_when: ufw_rm_web_3000.stdout != ""
      failed_when: false

    - name: Allow HTTP from Load Balancer only (webservers)
      ansible.builtin.command: ufw allow from 192.168.56.10 to any port 80 proto tcp
      register: ufw_allow_lb_web
      changed_when: "'Rules updated' in ufw_allow_lb_web.stdout"

    - name: Start Nginx
      systemd:
        name: nginx
        state: started
        enabled: yes

    - name: Allow devops to manage nginx without password
      copy:
        dest: /etc/sudoers.d/devops-nginx
        content: |
          devops ALL=(root) NOPASSWD: /usr/bin/install, /usr/sbin/nginx, /usr/bin/systemctl reload nginx, /usr/bin/systemctl restart nginx, /bin/ln, /bin/rm
        owner: root
        group: root
        mode: "0440"

  handlers:
    - name: reload ufw (webservers)
      ansible.builtin.command: ufw reload



# =========================================================
# 5) APP SERVER (UFW restricted)
#    - App port ONLY from web1/web2
# =========================================================
- name: Configure App Server
  hosts: appserver
  become: yes

  tasks:
    - name: Read UFW rules (numbered) on appserver
      ansible.builtin.command: ufw status numbered
      register: ufw_app_numbered
      changed_when: false

    - name: Remove public APP rules (3000/tcp Anywhere) on appserver
      ansible.builtin.shell: |
        set -e
        echo "{{ ufw_app_numbered.stdout }}" \
          | sed -n -E 's/^\[\s*([0-9]+)\]\s+3000\/tcp\s+ALLOW IN\s+Anywhere\s*$/\1/p' \
          | sort -rn \
          | while read -r n; do yes | ufw delete "$n"; done
      args:
        executable: /bin/bash
      register: ufw_rm_app_3000_any
      changed_when: ufw_rm_app_3000_any.stdout != ""
      failed_when: false

    - name: Remove public APP rules IPv6 (3000/tcp v6 Anywhere) on appserver
      ansible.builtin.shell: |
        set -e
        echo "{{ ufw_app_numbered.stdout }}" \
          | sed -n -E 's/^\[\s*([0-9]+)\]\s+3000\/tcp\s+\(v6\)\s+ALLOW IN\s+Anywhere\s+\(v6\)\s*$/\1/p' \
          | sort -rn \
          | while read -r n; do yes | ufw delete "$n"; done
      args:
        executable: /bin/bash
      register: ufw_rm_app_3000_v6_any
      changed_when: ufw_rm_app_3000_v6_any.stdout != ""
      failed_when: false

    - name: Allow app port only from web1
      ansible.builtin.command: ufw allow from 192.168.56.11 to any port 3000 proto tcp
      register: ufw_allow_app_web1
      changed_when: "'Rules updated' in ufw_allow_app_web1.stdout"

    - name: Allow app port only from web2
      ansible.builtin.command: ufw allow from 192.168.56.12 to any port 3000 proto tcp
      register: ufw_allow_app_web2
      changed_when: "'Rules updated' in ufw_allow_app_web2.stdout"

    # --- IMPORTANT: Docker published ports can bypass UFW, so restrict via DOCKER-USER ---
    - name: Ensure iptables persistence packages installed (appserver)
      ansible.builtin.apt:
        name:
          - iptables-persistent
          - netfilter-persistent
        state: present
        update_cache: yes

    - name: Ensure DOCKER-USER allows established connections (appserver)
      ansible.builtin.command: >
        iptables -C DOCKER-USER -m conntrack --ctstate RELATED,ESTABLISHED -j RETURN
      register: ipt_est
      failed_when: false
      changed_when: false

    - name: Insert established rule in DOCKER-USER if missing (appserver)
      ansible.builtin.command: >
        iptables -I DOCKER-USER 1 -m conntrack --ctstate RELATED,ESTABLISHED -j RETURN
      when: ipt_est.rc != 0

    - name: Allow 3000 from web1 in DOCKER-USER (appserver)
      ansible.builtin.command: >
        iptables -C DOCKER-USER -i enp0s8 -p tcp -s 192.168.56.11 --dport 3000 -j ACCEPT
      register: ipt_web1
      failed_when: false
      changed_when: false

    - name: Insert allow rule for web1 if missing (appserver)
      ansible.builtin.command: >
        iptables -I DOCKER-USER 2 -i enp0s8 -p tcp -s 192.168.56.11 --dport 3000 -j ACCEPT
      when: ipt_web1.rc != 0

    - name: Allow 3000 from web2 in DOCKER-USER (appserver)
      ansible.builtin.command: >
        iptables -C DOCKER-USER -i enp0s8 -p tcp -s 192.168.56.12 --dport 3000 -j ACCEPT
      register: ipt_web2
      failed_when: false
      changed_when: false

    - name: Insert allow rule for web2 if missing (appserver)
      ansible.builtin.command: >
        iptables -I DOCKER-USER 3 -i enp0s8 -p tcp -s 192.168.56.12 --dport 3000 -j ACCEPT
      when: ipt_web2.rc != 0

    - name: Drop 3000 from everyone else on host-only interface (appserver)
      ansible.builtin.command: >
        iptables -C DOCKER-USER -i enp0s8 -p tcp --dport 3000 -j DROP
      register: ipt_drop
      failed_when: false
      changed_when: false

    - name: Insert drop rule if missing (appserver)
      ansible.builtin.command: >
        iptables -I DOCKER-USER 4 -i enp0s8 -p tcp --dport 3000 -j DROP
      when: ipt_drop.rc != 0

    - name: Save iptables rules (appserver)
      ansible.builtin.command: netfilter-persistent save

# =========================================================
# 6) JENKINS (JCasC + Plugin Manager + Seed Job)
# =========================================================
- name: Install Jenkins (JCasC + plugins + seed job, no UI)
  hosts: jenkinsservers
  become: yes

  vars:
    jenkins_home: "/var/lib/jenkins"
    jcasc_dir: "/var/lib/jenkins/casc"
    jcasc_file: "/var/lib/jenkins/casc/jcasc.yml"
    plugins_txt: "/var/lib/jenkins/plugins.txt"
    plugin_manager_version: "2.13.2"
    plugin_manager_jar: "/usr/local/bin/jenkins-plugin-manager-{{ plugin_manager_version }}.jar"
    plugin_manager_url: "https://github.com/jenkinsci/plugin-installation-manager-tool/releases/download/{{ plugin_manager_version }}/jenkins-plugin-manager-{{ plugin_manager_version }}.jar"
    seed_job_dir: "/var/lib/jenkins/jobs/seed-job"
    seed_job_config: "/var/lib/jenkins/jobs/seed-job/config.xml"
    dsl_script_dest: "/var/lib/jenkins/jobs.groovy"

  tasks:
    - name: Install Java (Jenkins requires modern Java)
      apt:
        name: openjdk-17-jre
        state: present
        update_cache: yes

    - name: Add Jenkins GPG key
      apt_key:
        url: https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
        state: present

    - name: Add Jenkins repository
      apt_repository:
        repo: "deb https://pkg.jenkins.io/debian-stable binary/"
        state: present

    - name: Install Jenkins
      apt:
        name: jenkins
        state: present
        update_cache: yes

    - name: Read UFW rules (numbered) on jenkins
      ansible.builtin.command: ufw status numbered
      register: ufw_jenkins_numbered
      changed_when: false

    - name: Remove public Jenkins rule (8080 Anywhere) if present
      ansible.builtin.shell: |
        set -e
        echo "{{ ufw_jenkins_numbered.stdout }}" \
          | sed -n -E 's/^\[\s*([0-9]+)\]\s+8080\/tcp\s+ALLOW IN\s+Anywhere\s*$/\1/p' \
          | sort -rn \
          | while read -r n; do yes | ufw delete "$n"; done
      args:
        executable: /bin/bash
      register: ufw_rm_jenkins_8080_any
      changed_when: ufw_rm_jenkins_8080_any.stdout != ""
      failed_when: false

    - name: Remove public Jenkins rule IPv6 (8080 v6 Anywhere) if present
      ansible.builtin.shell: |
        set -e
        echo "{{ ufw_jenkins_numbered.stdout }}" \
          | sed -n -E 's/^\[\s*([0-9]+)\]\s+8080\/tcp\s+\(v6\)\s+ALLOW IN\s+Anywhere\s+\(v6\)\s*$/\1/p' \
          | sort -rn \
          | while read -r n; do yes | ufw delete "$n"; done
      args:
        executable: /bin/bash
      register: ufw_rm_jenkins_8080_v6_any
      changed_when: ufw_rm_jenkins_8080_v6_any.stdout != ""
      failed_when: false

    - name: Allow Jenkins only from host machine (192.168.56.1)
      ansible.builtin.command: ufw allow from 192.168.56.1 to any port 8080 proto tcp
      register: ufw_allow_jenkins_host
      changed_when: "'Rules updated' in ufw_allow_jenkins_host.stdout"

    - name: Ensure curl is installed
      apt:
        name: curl
        state: present

    - name: Create JCasC directory
      file:
        path: "{{ jcasc_dir }}"
        state: directory
        owner: jenkins
        group: jenkins
        mode: "0755"

    - name: Copy JCasC config
      copy:
        src: ../jenkins/jcasc.yml
        dest: "{{ jcasc_file }}"
        owner: jenkins
        group: jenkins
        mode: "0644"

    - name: Copy plugins.txt
      copy:
        src: ../jenkins/plugins.txt
        dest: "{{ plugins_txt }}"
        owner: jenkins
        group: jenkins
        mode: "0644"

    - name: Copy Job DSL script (jobs.groovy)
      copy:
        src: ../jenkins/jobs.groovy
        dest: "{{ dsl_script_dest }}"
        owner: jenkins
        group: jenkins
        mode: "0644"

    - name: Create seed job directory
      file:
        path: "{{ seed_job_dir }}"
        state: directory
        owner: jenkins
        group: jenkins
        mode: "0755"

    - name: Copy seed-job.xml to Jenkins job config.xml
      copy:
        src: ../jenkins/seed-job.xml
        dest: "{{ seed_job_config }}"
        owner: jenkins
        group: jenkins
        mode: "0644"

    - name: Disable Jenkins setup wizard and enable JCasC
      lineinfile:
        path: /etc/default/jenkins
        regexp: '^JAVA_ARGS='
        line: 'JAVA_ARGS="-Djava.awt.headless=true -Djenkins.install.runSetupWizard=false -Dcasc.jenkins.config={{ jcasc_file }}"'

    - name: Download Jenkins Plugin Manager
      get_url:
        url: "{{ plugin_manager_url }}"
        dest: "{{ plugin_manager_jar }}"
        mode: "0755"
      register: pm_dl
      retries: 5
      delay: 3
      until: pm_dl is succeeded

    - name: Install Jenkins plugins from plugins.txt
      shell: |
        java -jar {{ plugin_manager_jar }} \
          --war /usr/share/java/jenkins.war \
          --plugin-file {{ plugins_txt }} \
          --plugin-download-directory {{ jenkins_home }}/plugins
      args:
        creates: "{{ jenkins_home }}/plugins/configuration-as-code.jpi"
      register: pm_install

    - name: Ensure correct ownership of Jenkins home
      file:
        path: "{{ jenkins_home }}"
        state: directory
        owner: jenkins
        group: jenkins
        recurse: yes

    - name: Restart and enable Jenkins
      systemd:
        name: jenkins
        state: restarted
        enabled: yes

    - name: Wait for Jenkins to be ready
      wait_for:
        port: 8080
        delay: 5
        timeout: 240
